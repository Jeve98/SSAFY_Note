"""
[250823]

<알고리즘 라이브 강의>

비트 연산 : &, |, ^, ~, >>, <<
animation 상태 조절
flag : walk = false, attack = false, jump = false
>> flag : walk = 1 << 0, attack = 1 << 1, jump = 1 << 2
>> def set_state(state, flag) : return state | flag         - 현재 상태에 flag에 해당하는 상태와 or 연산
>> def unset_state(state, flag) : return state & ~flag      - 현재 상태에서 flag에 해당하지 않는 모든 상태와 and 연산


음수 표현 (2의 보수 사용에서도 부호 비트는 유지)
- 부호 비트만 사용 시, 저장 가능한 데이터의 양이 줄어들고, 음수-양수 간의 계산에서 오류가 생김
- 1의 보수 사용 시, (본래 비트를 모두 뒤집은 비트열을 음수로 사용할 경우) +0과 -0으로 분화하는 문제가 발생
- 2의 보수 사용 시, 1의 보수 + 1한 값을 음수로 사용하여 뺄셈의 연산 속도를 증가시키고 분화된 0을 다시 일원화
    ※ 2의 보수를 취한 값을 다시 2의 보수를 취하면 본 값으로 되돌아옴

실수 표현 : 무한 루프 방지를 위해 부동소수점으로 근사치 처리
>> 실제 계산에서 오차가 발생 가능


<실습>


"""